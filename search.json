[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My attempt at the CG:SHOP 2021 Challenge",
    "section": "",
    "text": "Also my first attempt at using nbdev."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "My attempt at the CG:SHOP 2021 Challenge",
    "section": "Install",
    "text": "Install\npip install your_project_name"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "My attempt at the CG:SHOP 2021 Challenge",
    "section": "How to use",
    "text": "How to use\nLetâ€™s see if this works\n\nsay_hello(\"CG:SHOP 2021\")\n\n'Hello CG:SHOP 2021.'"
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "module name here",
    "section": "",
    "text": "say_hello\n\n say_hello (to)\n\nSay hello to someone\nA function to say hello some someone.\n\nsay_hello(\"World\")\n\n\ntest_eq(say_hello(\"Jeff\"), \"Hello Jeff.\")\n\n\nnumpy.arccos(numpy.dot([0, -1], [-1, 0]))\n\n1.5707963267948966\n\n\n\nclass World:\n    def __init__(self):\n\n\nclass Robot:\n    def __init__(self, id, start, target):\n        self.id = id\n        self.name = str(id)\n        self.start = start\n        self.target = target\n\n\nr = Robot(0, (0, 0), (5, 5))\n\n\nr.start\n\n(0, 0)\n\n\n\nidb = InstanceDatabase(\"../data/cgshop_2021_instances_01.zip\")\n\nfor i in idb:\n    start_state = []\n    goal_state = []\n    robot_colors = []\n    obstacles = []\n    max_extent = 0\n    print(i.name)\n    print(f\"Number of Robots: {i.number_of_robots}\")\n    for r in range(i.number_of_robots):\n        # print(f\"Robot {r} starts at {i.start_of(r)} and has to go to {i.target_of(r)}\")\n        start_state.append((i.start_of(r)[0], i.start_of(r)[1]))\n        goal_state.append((i.target_of(r)[0], i.target_of(r)[1]))\n        max_extent = max([max_extent, i.start_of(r)[0], i.start_of(r)[1]])\n        robot_colors.append([random.randint(0, 254), random.randint(0, 254), random.randint(0, 254)])\n\n    for o in i.obstacles:\n        # print(f\"{o} is blocked\")\n        obstacles.append((o[0], o[1]))\n    break\n\nclouds_00000_20x20_40_160\nNumber of Robots: 160\n\n\n\ni.__dict__\n\n{'start': [(0, 15),\n  (18, 12),\n  (9, 9),\n  (6, 11),\n  (2, 7),\n  (14, 14),\n  (9, 12),\n  (15, 9),\n  (9, 15),\n  (7, 6),\n  (19, 4),\n  (0, 19),\n  (5, 4),\n  (10, 14),\n  (17, 8),\n  (9, 14),\n  (15, 10),\n  (0, 13),\n  (8, 8),\n  (17, 14),\n  (4, 17),\n  (14, 15),\n  (13, 19),\n  (13, 2),\n  (10, 0),\n  (8, 19),\n  (3, 6),\n  (18, 2),\n  (13, 15),\n  (6, 19),\n  (15, 7),\n  (16, 4),\n  (11, 13),\n  (11, 4),\n  (19, 8),\n  (2, 19),\n  (10, 3),\n  (2, 14),\n  (15, 1),\n  (2, 18),\n  (11, 0),\n  (5, 0),\n  (1, 10),\n  (19, 13),\n  (9, 18),\n  (5, 7),\n  (11, 12),\n  (15, 5),\n  (5, 3),\n  (3, 17),\n  (7, 11),\n  (15, 6),\n  (7, 19),\n  (2, 17),\n  (19, 1),\n  (5, 1),\n  (1, 6),\n  (5, 11),\n  (1, 15),\n  (13, 4),\n  (1, 13),\n  (5, 15),\n  (6, 15),\n  (18, 4),\n  (7, 7),\n  (1, 7),\n  (12, 12),\n  (18, 5),\n  (8, 14),\n  (8, 5),\n  (19, 2),\n  (8, 16),\n  (10, 9),\n  (5, 18),\n  (15, 4),\n  (13, 6),\n  (6, 17),\n  (8, 15),\n  (17, 6),\n  (10, 7),\n  (2, 13),\n  (3, 15),\n  (8, 17),\n  (18, 8),\n  (3, 2),\n  (9, 16),\n  (9, 19),\n  (13, 1),\n  (11, 2),\n  (12, 14),\n  (3, 13),\n  (6, 18),\n  (11, 7),\n  (6, 9),\n  (12, 0),\n  (14, 12),\n  (8, 18),\n  (13, 12),\n  (4, 1),\n  (13, 13),\n  (5, 12),\n  (2, 11),\n  (11, 1),\n  (12, 4),\n  (6, 10),\n  (1, 12),\n  (3, 11),\n  (17, 15),\n  (10, 12),\n  (6, 12),\n  (4, 8),\n  (12, 13),\n  (18, 9),\n  (2, 0),\n  (1, 14),\n  (16, 15),\n  (2, 15),\n  (11, 5),\n  (5, 10),\n  (8, 13),\n  (12, 6),\n  (13, 11),\n  (5, 8),\n  (5, 19),\n  (17, 10),\n  (6, 1),\n  (10, 10),\n  (17, 5),\n  (9, 11),\n  (7, 2),\n  (7, 18),\n  (12, 1),\n  (1, 18),\n  (8, 7),\n  (4, 3),\n  (9, 17),\n  (19, 15),\n  (7, 17),\n  (14, 8),\n  (16, 9),\n  (10, 15),\n  (2, 6),\n  (1, 16),\n  (11, 10),\n  (16, 10),\n  (10, 19),\n  (4, 13),\n  (7, 13),\n  (12, 3),\n  (2, 8),\n  (2, 12),\n  (3, 16),\n  (17, 12),\n  (14, 3),\n  (11, 16),\n  (3, 12),\n  (16, 0),\n  (3, 8),\n  (15, 0),\n  (15, 2)],\n 'target': [(7, 7),\n  (18, 13),\n  (11, 15),\n  (9, 6),\n  (10, 9),\n  (18, 17),\n  (11, 0),\n  (18, 16),\n  (6, 4),\n  (19, 16),\n  (10, 12),\n  (6, 3),\n  (8, 13),\n  (9, 2),\n  (19, 18),\n  (14, 6),\n  (15, 4),\n  (18, 4),\n  (8, 12),\n  (18, 19),\n  (6, 13),\n  (9, 19),\n  (17, 6),\n  (13, 14),\n  (15, 16),\n  (5, 1),\n  (4, 12),\n  (14, 13),\n  (13, 3),\n  (3, 12),\n  (17, 18),\n  (11, 9),\n  (15, 2),\n  (11, 18),\n  (16, 14),\n  (14, 7),\n  (17, 12),\n  (15, 1),\n  (17, 14),\n  (3, 5),\n  (13, 18),\n  (7, 6),\n  (5, 3),\n  (13, 11),\n  (5, 13),\n  (12, 9),\n  (16, 6),\n  (11, 11),\n  (16, 12),\n  (1, 6),\n  (11, 5),\n  (19, 15),\n  (10, 6),\n  (12, 4),\n  (11, 12),\n  (13, 4),\n  (19, 14),\n  (18, 6),\n  (8, 9),\n  (11, 13),\n  (8, 5),\n  (15, 8),\n  (7, 9),\n  (12, 13),\n  (16, 17),\n  (17, 17),\n  (6, 8),\n  (12, 14),\n  (9, 9),\n  (7, 19),\n  (10, 15),\n  (3, 9),\n  (17, 13),\n  (3, 3),\n  (19, 11),\n  (19, 12),\n  (17, 8),\n  (13, 10),\n  (18, 12),\n  (18, 14),\n  (8, 3),\n  (7, 2),\n  (11, 2),\n  (14, 17),\n  (7, 3),\n  (13, 13),\n  (7, 5),\n  (19, 17),\n  (17, 16),\n  (16, 19),\n  (10, 1),\n  (5, 4),\n  (15, 17),\n  (14, 11),\n  (17, 19),\n  (10, 19),\n  (8, 0),\n  (16, 8),\n  (12, 8),\n  (14, 19),\n  (5, 2),\n  (17, 5),\n  (11, 17),\n  (14, 14),\n  (6, 6),\n  (0, 8),\n  (3, 6),\n  (15, 18),\n  (4, 10),\n  (6, 12),\n  (18, 15),\n  (18, 5),\n  (15, 19),\n  (17, 9),\n  (3, 4),\n  (15, 12),\n  (13, 0),\n  (13, 16),\n  (12, 11),\n  (6, 2),\n  (10, 14),\n  (8, 4),\n  (9, 16),\n  (6, 5),\n  (11, 16),\n  (13, 15),\n  (16, 3),\n  (16, 11),\n  (14, 0),\n  (15, 15),\n  (5, 5),\n  (16, 15),\n  (0, 6),\n  (4, 17),\n  (16, 18),\n  (15, 3),\n  (18, 18),\n  (10, 11),\n  (9, 3),\n  (10, 13),\n  (18, 3),\n  (14, 15),\n  (2, 5),\n  (9, 11),\n  (11, 19),\n  (11, 4),\n  (1, 2),\n  (8, 10),\n  (18, 11),\n  (16, 16),\n  (13, 9),\n  (2, 11),\n  (12, 19),\n  (7, 8),\n  (11, 7),\n  (10, 7),\n  (12, 16),\n  (8, 14),\n  (13, 17),\n  (15, 14)],\n 'obstacles': [],\n 'at_position': {(0, 15): ('start', 0),\n  (7, 7): ('both', 64),\n  (18, 12): ('both', 78),\n  (18, 13): ('target', 1),\n  (9, 9): ('both', 68),\n  (11, 15): ('target', 2),\n  (6, 11): ('start', 3),\n  (9, 6): ('target', 3),\n  (2, 7): ('start', 4),\n  (10, 9): ('both', 72),\n  (14, 14): ('both', 103),\n  (18, 17): ('target', 5),\n  (9, 12): ('start', 6),\n  (11, 0): ('both', 40),\n  (15, 9): ('start', 7),\n  (18, 16): ('target', 7),\n  (9, 15): ('start', 8),\n  (6, 4): ('target', 8),\n  (7, 6): ('both', 41),\n  (19, 16): ('target', 9),\n  (19, 4): ('start', 10),\n  (10, 12): ('both', 108),\n  (0, 19): ('start', 11),\n  (6, 3): ('target', 11),\n  (5, 4): ('both', 91),\n  (8, 13): ('both', 119),\n  (10, 14): ('both', 120),\n  (9, 2): ('target', 13),\n  (17, 8): ('both', 76),\n  (19, 18): ('target', 14),\n  (9, 14): ('start', 15),\n  (14, 6): ('target', 15),\n  (15, 10): ('start', 16),\n  (15, 4): ('both', 74),\n  (0, 13): ('start', 17),\n  (18, 4): ('both', 63),\n  (8, 8): ('start', 18),\n  (8, 12): ('target', 18),\n  (17, 14): ('both', 38),\n  (18, 19): ('target', 19),\n  (4, 17): ('both', 133),\n  (6, 13): ('target', 20),\n  (14, 15): ('both', 141),\n  (9, 19): ('both', 86),\n  (13, 19): ('start', 22),\n  (17, 6): ('both', 78),\n  (13, 2): ('start', 23),\n  (13, 14): ('target', 23),\n  (10, 0): ('start', 24),\n  (15, 16): ('target', 24),\n  (8, 19): ('start', 25),\n  (5, 1): ('both', 55),\n  (3, 6): ('both', 106),\n  (4, 12): ('target', 26),\n  (18, 2): ('start', 27),\n  (14, 13): ('target', 27),\n  (13, 15): ('both', 125),\n  (13, 3): ('target', 28),\n  (6, 19): ('start', 29),\n  (3, 12): ('both', 155),\n  (15, 7): ('start', 30),\n  (17, 18): ('target', 30),\n  (16, 4): ('start', 31),\n  (11, 9): ('target', 31),\n  (11, 13): ('both', 59),\n  (15, 2): ('both', 159),\n  (11, 4): ('both', 145),\n  (11, 18): ('target', 33),\n  (19, 8): ('start', 34),\n  (16, 14): ('target', 34),\n  (2, 19): ('start', 35),\n  (14, 7): ('target', 35),\n  (10, 3): ('start', 36),\n  (17, 12): ('both', 152),\n  (2, 14): ('start', 37),\n  (15, 1): ('both', 38),\n  (2, 18): ('start', 39),\n  (3, 5): ('target', 39),\n  (13, 18): ('target', 40),\n  (5, 0): ('start', 41),\n  (1, 10): ('start', 42),\n  (5, 3): ('both', 48),\n  (19, 13): ('start', 43),\n  (13, 11): ('both', 121),\n  (9, 18): ('start', 44),\n  (5, 13): ('target', 44),\n  (5, 7): ('start', 45),\n  (12, 9): ('target', 45),\n  (11, 12): ('both', 54),\n  (16, 6): ('target', 46),\n  (15, 5): ('start', 47),\n  (11, 11): ('target', 47),\n  (16, 12): ('target', 48),\n  (3, 17): ('start', 49),\n  (1, 6): ('both', 56),\n  (7, 11): ('start', 50),\n  (11, 5): ('both', 117),\n  (15, 6): ('start', 51),\n  (19, 15): ('both', 136),\n  (7, 19): ('both', 69),\n  (10, 6): ('target', 52),\n  (2, 17): ('start', 53),\n  (12, 4): ('both', 103),\n  (19, 1): ('start', 54),\n  (13, 4): ('both', 59),\n  (19, 14): ('target', 56),\n  (5, 11): ('start', 57),\n  (18, 6): ('target', 57),\n  (1, 15): ('start', 58),\n  (8, 9): ('target', 58),\n  (1, 13): ('start', 60),\n  (8, 5): ('both', 69),\n  (5, 15): ('start', 61),\n  (15, 8): ('target', 61),\n  (6, 15): ('start', 62),\n  (7, 9): ('target', 62),\n  (12, 13): ('both', 111),\n  (16, 17): ('target', 64),\n  (1, 7): ('start', 65),\n  (17, 17): ('target', 65),\n  (12, 12): ('start', 66),\n  (6, 8): ('target', 66),\n  (18, 5): ('both', 111),\n  (12, 14): ('both', 89),\n  (8, 14): ('both', 157),\n  (19, 2): ('start', 70),\n  (10, 15): ('both', 140),\n  (8, 16): ('start', 71),\n  (3, 9): ('target', 71),\n  (17, 13): ('target', 72),\n  (5, 18): ('start', 73),\n  (3, 3): ('target', 73),\n  (19, 11): ('target', 74),\n  (13, 6): ('start', 75),\n  (19, 12): ('target', 75),\n  (6, 17): ('start', 76),\n  (8, 15): ('start', 77),\n  (13, 10): ('target', 77),\n  (10, 7): ('both', 155),\n  (18, 14): ('target', 79),\n  (2, 13): ('start', 80),\n  (8, 3): ('target', 80),\n  (3, 15): ('start', 81),\n  (7, 2): ('both', 129),\n  (8, 17): ('start', 82),\n  (11, 2): ('both', 88),\n  (18, 8): ('start', 83),\n  (14, 17): ('target', 83),\n  (3, 2): ('start', 84),\n  (7, 3): ('target', 84),\n  (9, 16): ('both', 122),\n  (13, 13): ('both', 99),\n  (7, 5): ('target', 86),\n  (13, 1): ('start', 87),\n  (19, 17): ('target', 87),\n  (17, 16): ('target', 88),\n  (16, 19): ('target', 89),\n  (3, 13): ('start', 90),\n  (10, 1): ('target', 90),\n  (6, 18): ('start', 91),\n  (11, 7): ('both', 154),\n  (15, 17): ('target', 92),\n  (6, 9): ('start', 93),\n  (14, 11): ('target', 93),\n  (12, 0): ('start', 94),\n  (17, 19): ('target', 94),\n  (14, 12): ('start', 95),\n  (10, 19): ('both', 145),\n  (8, 18): ('start', 96),\n  (8, 0): ('target', 96),\n  (13, 12): ('start', 97),\n  (16, 8): ('target', 97),\n  (4, 1): ('start', 98),\n  (12, 8): ('target', 98),\n  (14, 19): ('target', 99),\n  (5, 12): ('start', 100),\n  (5, 2): ('target', 100),\n  (2, 11): ('both', 151),\n  (17, 5): ('both', 127),\n  (11, 1): ('start', 102),\n  (11, 17): ('target', 102),\n  (6, 10): ('start', 104),\n  (6, 6): ('target', 104),\n  (1, 12): ('start', 105),\n  (0, 8): ('target', 105),\n  (3, 11): ('start', 106),\n  (17, 15): ('start', 107),\n  (15, 18): ('target', 107),\n  (4, 10): ('target', 108),\n  (6, 12): ('target', 109),\n  (4, 8): ('start', 110),\n  (18, 15): ('target', 110),\n  (18, 9): ('start', 112),\n  (15, 19): ('target', 112),\n  (2, 0): ('start', 113),\n  (17, 9): ('target', 113),\n  (1, 14): ('start', 114),\n  (3, 4): ('target', 114),\n  (16, 15): ('both', 131),\n  (15, 12): ('target', 115),\n  (2, 15): ('start', 116),\n  (13, 0): ('target', 116),\n  (13, 16): ('target', 117),\n  (5, 10): ('start', 118),\n  (12, 11): ('target', 118),\n  (6, 2): ('target', 119),\n  (12, 6): ('start', 120),\n  (8, 4): ('target', 121),\n  (5, 8): ('start', 122),\n  (5, 19): ('start', 123),\n  (6, 5): ('target', 123),\n  (17, 10): ('start', 124),\n  (11, 16): ('both', 154),\n  (6, 1): ('start', 125),\n  (10, 10): ('start', 126),\n  (16, 3): ('target', 126),\n  (16, 11): ('target', 127),\n  (9, 11): ('both', 143),\n  (14, 0): ('target', 128),\n  (15, 15): ('target', 129),\n  (7, 18): ('start', 130),\n  (5, 5): ('target', 130),\n  (12, 1): ('start', 131),\n  (1, 18): ('start', 132),\n  (0, 6): ('target', 132),\n  (8, 7): ('start', 133),\n  (4, 3): ('start', 134),\n  (16, 18): ('target', 134),\n  (9, 17): ('start', 135),\n  (15, 3): ('target', 135),\n  (18, 18): ('target', 136),\n  (7, 17): ('start', 137),\n  (10, 11): ('target', 137),\n  (14, 8): ('start', 138),\n  (9, 3): ('target', 138),\n  (16, 9): ('start', 139),\n  (10, 13): ('target', 139),\n  (18, 3): ('target', 140),\n  (2, 6): ('start', 141),\n  (1, 16): ('start', 142),\n  (2, 5): ('target', 142),\n  (11, 10): ('start', 143),\n  (16, 10): ('start', 144),\n  (11, 19): ('target', 144),\n  (4, 13): ('start', 146),\n  (1, 2): ('target', 146),\n  (7, 13): ('start', 147),\n  (8, 10): ('target', 147),\n  (12, 3): ('start', 148),\n  (18, 11): ('target', 148),\n  (2, 8): ('start', 149),\n  (16, 16): ('target', 149),\n  (2, 12): ('start', 150),\n  (13, 9): ('target', 150),\n  (3, 16): ('start', 151),\n  (12, 19): ('target', 152),\n  (14, 3): ('start', 153),\n  (7, 8): ('target', 153),\n  (16, 0): ('start', 156),\n  (12, 16): ('target', 156),\n  (3, 8): ('start', 157),\n  (15, 0): ('start', 158),\n  (13, 17): ('target', 158),\n  (15, 14): ('target', 159)},\n 'number_of_robots': 160,\n 'name': 'clouds_00000_20x20_40_160',\n 'description': {'parameters': {'seed': 7700,\n   'shape': [20, 20],\n   'obstacles': {'n': 0, 'mean': 3, 'std': 1.5},\n   'clusters': {'n': 5,\n    'mean': 40,\n    'std': 20.0,\n    'relative_radius': 2,\n    'increase_factor': 1.3,\n    'start_dist': {'generator_name': 'Image',\n     'shape': [20, 20],\n     'min': 5.0,\n     'max': 195.0,\n     'mean': 115.0,\n     'std': 30.23127519639223,\n     'dtype': 'uint64',\n     'parameters': {'image': 'clouds.png',\n      'transformer': {'name': 'ColorChannelSelector',\n       'channel': 'v',\n       'inverted': False}}},\n    'target_dist': {'generator_name': 'Image',\n     'shape': [20, 20],\n     'min': 5.0,\n     'max': 195.0,\n     'mean': 115.0,\n     'std': 30.23127519639223,\n     'dtype': 'uint64',\n     'parameters': {'image': 'clouds.png',\n      'transformer': {'name': 'ColorChannelSelector',\n       'channel': 'v',\n       'inverted': False}}}},\n   'density': 0.4,\n   'start_dist': {'generator_name': 'Image',\n    'shape': [20, 20],\n    'min': 5.0,\n    'max': 195.0,\n    'mean': 115.0,\n    'std': 30.23127519639223,\n    'dtype': 'uint64',\n    'parameters': {'image': 'clouds.png',\n     'transformer': {'name': 'ColorChannelSelector',\n      'channel': 'v',\n      'inverted': False}}},\n   'target_dist': {'generator_name': 'Image',\n    'shape': [20, 20],\n    'min': 5.0,\n    'max': 195.0,\n    'mean': 115.0,\n    'std': 30.23127519639223,\n    'dtype': 'uint64',\n    'parameters': {'image': 'clouds.png',\n     'transformer': {'name': 'ColorChannelSelector',\n      'channel': 'v',\n      'inverted': False}}}},\n  'stats': {'date': '2020-11-17',\n   'free_area': 400.0,\n   'number_of_clustered_robots': 160,\n   'number_of_robots': 160}}}\n\n\n\nfrom ipywidgets import Layout, IntProgress\nfrom IPython.display import display\nimport time\n\n\nmax_count = 100\n\nf = IntProgress(min=0, max=max_count) # instantiate the bar\ndisplay(f) # display the bar\n\ncount = 0\nwhile count <= max_count:\n    f.value += 1 # signal to increment the progress bar\n    time.sleep(.1)\n    count += 1\n\n\n\n\n\nclass Animation:\n    def __init__(self, starts, goals, obstacles, actions):\n        self.starts = []\n        for start in starts:\n            self.starts.append((start[0], start[1]))\n        self.goals = []\n        for goal in goals:\n            self.goals.append((goal[0], goal[1]))\n        self.obstacles = []\n        for obstacle in obstacles:\n            self.obstacles.append((obstacle[0], obstacle[1]))\n        self.actions = []\n        if actions:\n            for action in actions:\n                self.actions.append([])\n                for movement in action:\n                    self.actions[-1].append((movement[0], movement[1]))\n        self.paths = numpy.cumsum(numpy.insert(numpy.array(self.actions), 0, numpy.array(self.starts), axis=1), axis=1)\n\n        self.x_min_orig = min(min([i[0] for i in self.starts]), \n                              min([i[0] for i in self.goals]))\n        self.y_min_orig = min(min([i[1] for i in self.starts]), \n                              min([i[1] for i in self.goals]))\n        self.x_max_orig = max(max([i[0] for i in self.starts]), \n                              max([i[0] for i in self.goals]))\n        self.y_max_orig = max(max([i[1] for i in self.starts]), \n                              max([i[1] for i in self.goals]))\n        \n        if self.obstacles:\n            self.x_min_orig = min(self.x_min_orig, min([i[0] for i in self.obstacles]))\n            self.y_min_orig = min(self.y_min_orig, min([i[1] for i in self.obstacles]))\n            self.x_max_orig = max(self.x_max_orig, max([i[0] for i in self.obstacles]))\n            self.y_max_orig = max(self.y_max_orig, max([i[1] for i in self.obstacles]))\n        \n        aspect = (self.x_max_orig - self.x_min_orig) / (self.y_max_orig - self.y_min_orig)\n\n        \n        plt.ioff()\n\n        self.fig = plt.figure(frameon=False, figsize=(5 * aspect, 5))\n        self.ax = self.fig.add_subplot(111, aspect='equal')\n        self.fig.subplots_adjust(left=0, right=1, bottom=0, top=1, wspace=None, hspace=None)\n        # self.ax.set_frame_on(False)\n\n        self.patches = []\n        self.artists = []\n        self.agents = {}\n        self.agent_names = {}\n        \n        plt.xlim(self.x_min_orig, self.x_max_orig + 1)\n        plt.ylim(self.y_min_orig, self.y_max_orig + 1)\n\n        for obstacle in self.obstacles:\n            self.patches.append(Rectangle((obstacle[0], obstacle[1]), 1, 1, facecolor='black', edgecolor='none'))\n\n        # create agents:\n        # draw goals first\n        for i, goal in enumerate(self.goals):\n            self.patches.append(Rectangle((goal[0], goal[1]), 1, 1, \n                                          facecolor='white',\n                                          edgecolor='gray', linewidth=1, alpha=0.5))\n            \n            if len(self.starts) <= 200:\n            # if (self.x_max_orig - self.x_min_orig <= 25) and (self.y_max_orig - self.y_min_orig) <= 25:\n                self.artists.append(self.ax.text(goal[0] + 0.5, goal[1] + 0.25, str(i), \n                                                 color='gray', fontsize=6, alpha=0.5, \n                                                 horizontalalignment='center', verticalalignment='center'))\n        \n        self.T = max([len(self.actions[i]) - 1 for i in range(len(self.actions))])\n        style = {'description_width': 'initial'}\n        self.progress = IntProgress(min=0, max=int(self.T + 1) * 10, \n                                    description='Creating Animation', style=style)\n        display.display(self.progress) # display the bar\n        \n        for i in range(len(self.starts)):\n            name = str(i)\n            self.agents[i] = Rectangle((self.starts[i][0], self.starts[i][1]), 1, 1, \n                                       facecolor='#bdbdbd',\n                                       edgecolor='gray')\n            self.agents[i].original_face_color = '#bdbdbd'\n            self.patches.append(self.agents[i])\n            if len(self.starts) <= 200:\n            # if (self.x_max_orig - self.x_min_orig <= 25) and (self.y_max_orig - self.y_min_orig) <= 25:\n                self.agent_names[i] = self.ax.text(self.starts[i][0], self.starts[i][1], name, fontsize=6)\n                self.agent_names[i].set_horizontalalignment('center')\n                self.agent_names[i].set_verticalalignment('center')\n                self.artists.append(self.agent_names[i])\n                \n        self.animation = animation.FuncAnimation(self.fig, self.animate_func,\n                                                 init_func=self.init_func,\n                                                 frames=int(self.T + 1) * 10,\n                                                 interval=50,\n                                                 blit=True)\n        \n        self.video = self.animation.to_html5_video()\n        display.clear_output(wait=False)\n        html = display.HTML(self.video)\n        display.display(html)\n\n    def save(self, file_name):\n        self.animation.save(\n            file_name,\n            fps=(1000 / 50.),\n            dpi=200,\n            savefig_kwargs={\"pad_inches\": 0, \"bbox_inches\": \"tight\"})\n\n    @staticmethod\n    def show():\n        plt.show()\n        \n    @staticmethod\n    def close():\n        plt.close()\n\n    def init_func(self):\n        [p.remove() for p in reversed(self.ax.patches)]\n        [a.remove() for a in reversed(self.ax.artists)]\n        plt.axis('off')\n        \n        for p in self.patches:\n            self.ax.add_patch(p)\n        for a in self.artists:\n            self.ax.add_artist(a)\n        return self.patches + self.artists\n\n    def animate_func(self, t):\n        self.progress.value = t\n        for k in range(len(self.paths)):\n            pos = self.get_state(t / 10, self.paths[k])\n            self.agents[k].xy = (pos[0], pos[1])\n            self.agents[k].width = 1\n            self.agents[k].height = 1\n            if len(self.agent_names) > 0:\n                self.agent_names[k].set_position((pos[0] + 0.5, pos[1] + 0.75))\n            \n        mins_maxs = {'x_min': numpy.inf, 'y_min': numpy.inf, 'x_max': -numpy.inf, 'y_max': -numpy.inf}\n        for patch in self.patches:\n            mins_maxs['x_min'] = min(mins_maxs['x_min'], patch.xy[0])\n            mins_maxs['y_min'] = min(mins_maxs['y_min'], patch.xy[1])\n            mins_maxs['x_max'] = max(mins_maxs['x_max'], patch.xy[0])\n            mins_maxs['y_max'] = max(mins_maxs['y_max'], patch.xy[1])\n\n        x_min = min(self.x_min_orig, mins_maxs['x_min'])\n        y_min = min(self.y_min_orig, mins_maxs['y_min'])\n        x_max = max(self.x_max_orig, mins_maxs['x_max'])\n        y_max = max(self.y_max_orig, mins_maxs['y_max'])\n        plt.xlim(x_min, x_max + 1)\n        plt.ylim(y_min, y_max + 1)\n            \n        agents_array = []\n        for i, agent in self.agents.items():\n            # reset all colors\n            agent.set_facecolor(agent.original_face_color)\n            agent.set_edgecolor('gray')\n            agents_array.append(agent.xy)\n            if agent.xy == self.goals[i]:\n                agent.set_facecolor('#4daf4a')\n                agent.set_edgecolor('#4daf4a')\n                \n\n        # check drive-drive collisions\n        agents_array = numpy.array(agents_array)\n        norms = numpy.zeros((agents_array.shape[0], agents_array.shape[0]))\n        for i in range(1, len(agents_array)):\n            temp = agents_array[i, np.newaxis] - agents_array[:]\n            norms[i, :] = np.linalg.norm(temp, axis=1)\n        \n        collisions = numpy.argwhere((norms > 0) & (norms < 0.999999))\n        if collisions.size > 0:\n            for c in collisions:\n                if c[0] < c[1]:\n                    self.agents.get(c[0]).set_facecolor('#e41a1c')\n                    self.agents.get(c[1]).set_facecolor('#e41a1c')\n                    print(f\"Collision between {c[0]} and {c[1]} at time {t / 10}.\")\n\n        \"\"\"agents_array = [agent for _, agent in self.agents.items()]\n        for i in range(0, len(agents_array)):\n            for j in range(i + 1, len(agents_array)):\n                d1 = agents_array[i]\n                d2 = agents_array[j]\n                pos1 = np.array(d1.xy)\n                pos2 = np.array(d2.xy)\n                if np.linalg.norm(pos1 - pos2) < 0.999999:\n                    d1.set_facecolor('red')\n                    d2.set_facecolor('red')\n                    print(f\"Collision between {i} and {j} at time {t / 10}.\")\"\"\"\n\n        return self.patches + self.artists\n\n    @staticmethod\n    def get_state(t, path):\n        if int(t) <= 0:\n            return np.array(path[0])\n        elif int(t) >= len(path):\n            return np.array(path[-1])\n        else:\n            pos_last = np.array(path[int(t) - 1])\n            pos_next = np.array(path[int(t)])\n            pos = (pos_next - pos_last) * (t - int(t)) + pos_last\n            return pos\n\n\nactions = []\n\nfor i in range(len(start_state)):\n    actions.append([(1, 0), \n                  (0, -1),\n                  (0, -1),\n                  (-1, 0), \n                  (0, 1),\n                   (1, 0), \n                  (0, -1),\n                  (0, -1),\n                  (-1, 0), \n                  (0, 1),\n                   (1, 0), \n                  (0, -1),\n                  (0, -1),\n                  (-1, 0), \n                  (0, 1),\n                   (1, 0), \n                  (0, -1),\n                  (0, -1),\n                  (-1, 0), \n                  (0, 1),\n                   (1, 0), \n                  (0, -1),\n                  (0, -1),\n                  (-1, 0), \n                  (0, 1)])\n\n\na = Animation(start_state, goal_state, obstacles, actions)\n\n\n  \n  Your browser does not support the video tag.\n\n\n\nCPU times: user 2min 16s, sys: 3.95 s, total: 2min 20s\nWall time: 3min\n\n\n\na.save(file_name=\"../outputs/test.mp4\")\n\nWarning: discarding the 'bbox_inches' argument in 'savefig_kwargs' as it may cause frame size to vary, which is inappropriate for animation.\n\n\nCPU times: user 3min 22s, sys: 6.12 s, total: 3min 29s\nWall time: 5min 6s\n\n\n\ndef is_valid_move():\n    if numpy.arccos(numpy.dot([0, -1], [-1, 0])) > 0:\n        return False\n    return True\n\n\ndef create_solution_file(instance, actions, outdir):\n    action_map = {(0, 1): \"N\", (0, -1): \"S\", (1, 0): \"E\", (-1, 0): \"W\", (0, 0): None}\n    directional_actions = actions\n    steps = []\n    \n    for agent in range(len(actions)):\n        for action in range(len(actions[agent])):\n            directional_actions[agent][action] = action_map[actions[agent][action]]\n        steps.append({str(t): directional_actions[agent][t] \n                      for t in range(len(directional_actions[agent])) \n                      if directional_actions[agent][t] is not None})\n    \n    file = {}\n    file[\"instance\"] = instance.name\n    file[\"steps\"] = steps\n    file = json.dumps(file, indent=4)\n    \n    with open(f\"{outdir}/{instance.name}_sol.json\", \"w\") as outfile:\n        outfile.write(file)\n\n\ncreate_solution_file(list(idb)[0], actions, \"../outputs\")\n\n\nf = lambda x: Rectangle((x[0], x[1]), 1, 1, facecolor='gray', edgecolor='gray')\nstarts = numpy.array(start_state)\nnumpy.apply_along_axis(f, 1, starts)\n\n\nagents = {}\nfor i in range(len(starts)):\n    agents[i] = Rectangle((starts[i][0], starts[i][1]), 1, 1, \n                               facecolor='gray',\n                               edgecolor='gray')\n\n\nx = np.linspace(0, 2 * np.pi, 100)\n\nfig = plt.figure()\n\nlines = plt.plot([])\nline = lines[0]\nplt.xlim(0, 2 * np.pi)\nplt.ylim(-1.1, 1.1)\n\ndef animate(frame):\n    y = np.sin(x + 2 * np.pi * frame / 100)\n    line.set_data((x, y))\n\nanim = FuncAnimation(fig, animate, frames=100, interval=20)\nvideo = anim.to_html5_video()\nhtml = display.HTML(video)\ndisplay.display(html)\nplt.close()\n\n\n\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\ncol.properties()\n\n\nagents\n\n\na.targets[0].get_edgecolor()\n\n\na.targets[0].set_edgecolor('#4daf4a')\na.targets[0].get_edgecolor()\n\n\nt = 33\nfor k in range(len(a.paths)):\n    if int(t) <= 0:\n        pos = np.array(a.paths[k][0])\n    elif int(t) >= len(a.paths[k]):\n        pos = np.array(a.paths[k][-1])\n    else:\n        pos_last = np.array(a.paths[k][int(t) - 1])\n        pos_next = np.array(a.paths[k][int(t)])\n        pos = (pos_next - pos_last) * (t - int(t)) + pos_last\n    # pos = a.get_state(t / 10, a.paths[k])\n    pos = [0, 0]\n    a.agents[k].xy = (pos[0], pos[1])\n    a.agents[k].width = 1\n    a.agents[k].height = 1\n    a.agent_names[k].set_position((pos[0] + 0.5, pos[1] + 0.75))\n\n\nagents_array = []\nfor _, agent in a.agents.items():\n    # reset all colors\n    agent.set_facecolor(agent.original_face_color)\n    agents_array.append(agent.xy)\n\n\nnumpy.array(a.paths).shape\n\n\n#!/usr/bin/env python3\nfrom matplotlib.patches import Circle, Rectangle\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib import animation\n\n\nColors = ['green', 'blue', 'orange']\n\n\nclass Animation:\n    def __init__(self, my_map, starts, goals, paths):\n        self.my_map = np.transpose(my_map)\n        # self.my_map = np.flip(np.transpose(my_map), 1)\n        self.starts = []\n        for start in starts:\n            self.starts.append((start[0], start[1]))\n        self.goals = []\n        for goal in goals:\n            self.goals.append((goal[0], goal[1]))\n        self.paths = []\n        if paths:\n            for path in paths:\n                self.paths.append([])\n                for loc in path:\n                    self.paths[-1].append((loc[0], loc[1]))\n\n        aspect = len(self.my_map) / len(self.my_map[0])\n\n        self.fig = plt.figure(frameon=False, figsize=(5 * aspect, 5))\n        self.ax = self.fig.add_subplot(111, aspect='equal')\n        self.fig.subplots_adjust(left=0, right=1, bottom=0, top=1, wspace=None, hspace=None)\n        # self.ax.set_frame_on(False)\n\n        self.patches = []\n        self.artists = []\n        self.agents = {}\n        self.agent_names = {}\n        \n        x_min = -0.5\n        y_min = -0.5\n        x_max = len(self.my_map) - 0.5\n        y_max = len(self.my_map[0]) - 0.5\n        plt.xlim(x_min, x_max)\n        plt.ylim(y_min, y_max)\n\n        for i in range(len(self.my_map)):\n            for j in range(len(self.my_map[0])):\n                if self.my_map[i][j]:\n                    self.patches.append(Rectangle((i, j), 1, 1, facecolor='gray', edgecolor='gray'))\n\n        # create agents:\n        self.T = 0\n        # draw goals first\n        for i, goal in enumerate(self.goals):\n            self.patches.append(Rectangle((goal[0], goal[1]), 1, 1, \n                                          facecolor='white',\n                                          edgecolor=Colors[i % len(Colors)], linewidth=2, alpha=0.5))\n            self.artists.append(self.ax.text(goal[0] + 0.5, goal[1] + 0.5, str(i), \n                                             color=Colors[i % len(Colors)], fontsize=8, alpha=0.5, \n                                             horizontalalignment='center', verticalalignment='center'))\n        for i in range(len(self.paths)):\n            name = str(i)\n            self.agents[i] = Rectangle((starts[i][0], starts[i][1]), 1, 1, \n                                       facecolor=Colors[i % len(Colors)],\n                                       edgecolor=Colors[i % len(Colors)])\n            self.agents[i].original_face_color = Colors[i % len(Colors)]\n            self.patches.append(self.agents[i])\n            self.T = max(self.T, len(paths[i]) - 1)\n            self.agent_names[i] = self.ax.text(starts[i][0], starts[i][1], name, fontsize=8)\n            self.agent_names[i].set_horizontalalignment('center')\n            self.agent_names[i].set_verticalalignment('center')\n            self.artists.append(self.agent_names[i])\n\n        self.animation = animation.FuncAnimation(self.fig, self.animate_func,\n                                                 init_func=self.init_func,\n                                                 frames=int(self.T + 1) * 10,\n                                                 interval=100,\n                                                 blit=True)\n\n    def save(self, file_name, speed):\n        self.animation.save(\n            file_name,\n            fps=10 * speed,\n            dpi=200,\n            savefig_kwargs={\"pad_inches\": 0, \"bbox_inches\": \"tight\"})\n\n    @staticmethod\n    def show():\n        plt.show()\n\n    def init_func(self):\n        [p.remove() for p in reversed(self.ax.patches)]\n        [a.remove() for a in reversed(self.ax.artists)]\n        plt.axis('off')\n        \n        for p in self.patches:\n            self.ax.add_patch(p)\n        for a in self.artists:\n            self.ax.add_artist(a)\n        return self.patches + self.artists\n\n    def animate_func(self, t):\n        for k in range(len(self.paths)):\n            pos = self.get_state(t / 10, self.paths[k])\n            self.agents[k].xy = (pos[0], pos[1])\n            self.agents[k].width = 1\n            self.agents[k].height = 1\n            self.agent_names[k].set_position((pos[0] + 0.5, pos[1] + 0.75))\n\n        x_min = min([0] + [agent.xy[0] for _, agent in self.agents.items()])\n        y_min = min([0] + [agent.xy[1] for _, agent in self.agents.items()])\n        x_max = max([len(self.my_map)] + [agent.xy[0] + agent.width for _, agent in self.agents.items()])\n        y_max = max([len(self.my_map[0])] + [agent.xy[1] + agent.height for _, agent in self.agents.items()])\n        plt.xlim(x_min, x_max)\n        plt.ylim(y_min, y_max)\n            \n        # reset all colors\n        for _, agent in self.agents.items():\n            agent.set_facecolor(agent.original_face_color)\n\n        # check drive-drive collisions\n        agents_array = [agent for _, agent in self.agents.items()]\n        for i in range(0, len(agents_array)):\n            for j in range(i + 1, len(agents_array)):\n                d1 = agents_array[i]\n                d2 = agents_array[j]\n                pos1 = np.array(d1.xy)\n                pos2 = np.array(d2.xy)\n                if np.linalg.norm(pos1 - pos2) < 1:\n                    d1.set_facecolor('red')\n                    d2.set_facecolor('red')\n                    print(f\"Collision between {i} and {j} at time {t / 10}.\")\n\n        return self.patches + self.artists\n\n    @staticmethod\n    def get_state(t, path):\n        if int(t) <= 0:\n            return np.array(path[0])\n        elif int(t) >= len(path):\n            return np.array(path[-1])\n        else:\n            pos_last = np.array(path[int(t) - 1])\n            pos_next = np.array(path[int(t)])\n            pos = (pos_next - pos_last) * (t - int(t)) + pos_last\n            return pos\n\n\nmy_map = numpy.array([[False, False, True, False, False, False, False, False],\n                      [False, False, False, True, False, False, False, False],\n                      [False, False, True, False, False, False, False, False],\n                      [False, False, False, False, False, False, False, False],\n                      [False, False, False, False, False, False, False, True],\n                      [False, False, False, False, False, True, False, False],\n                      [False, False, False, False, False, False, True, False],\n                      [False, False, False, False, False, False, False, False]])\nstarts = [(1, 1), (7, 6), (4, 3), (0, 0), (1, 0)]\ngoals = [(3, 0), (0, 0), (1, 1), (5, 4), (5, 6)]\npaths = [[(1, 1), (1, 0), (2, 0), (3, 0), (3, -1), (3, 0)], \n         [(7, 6), (7, 5), (7, 4), (7, 3), (7, 2), (7, 1), (6, 1), (5, 1), (4, 1), (3, 1), (2, 1), (2, 0), (1, 0), (0, 0)], \n         [(4, 3), (4, 2), (3, 2), (3, 2), (3, 2), (3, 1), (2, 1), (1, 1)], \n         [(0, 0), (0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (5, 2), (5, 3), (5, 4)], \n         [(1, 0), (2, 0), (3, 0), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 6)]]\n\na = Animation(my_map, starts, goals, paths)\n\n\nrobot_colors\n\n\nfig = pyplot.figure(figsize=(5, 5))\ndimension = (max_extent + 1, max_extent + 1)\n\ndef init():\n    labels = numpy.zeros(dimension, dtype=str)\n    data = numpy.zeros(max_extent + 1, max_extent + 1, 3)\n    for i in range(len(current_state)):\n        labels[current_state[i][0], current_state[i][1]] = str(i)\n        data[current_state[i][0], current_state[i][1]] = robot_colors[i]\n    seaborn.heatmap(data, cbar=False, annot=labels, fmt='')\n\ndef animate(i):\n    pyplot.cla()\n    # data = numpy.random.rand(dimension[0], dimension[1])\n    # labels = numpy.random.choice(['X', 'O', '+', '-'], size=dimension)\n    seaborn.heatmap(data, cbar=False, annot=labels, fmt='')\n\nanim = FuncAnimation(fig, animate, init_func=init, frames=20, repeat=False)\n\npyplot.show()\n\n\nw, h = 512, 512\ndata = numpy.zeros((h, w, 3), dtype=numpy.uint8)\ndata[0:256, 0:128] = [0, 255, 0] # white patch in upper left\nImage.fromarray(data, 'RGB')\n\n\nfig, ax = pyplot.subplots()\nmat = ax.imshow(data, origin='lower')\npyplot.show()\n\n\ndata.shape"
  }
]